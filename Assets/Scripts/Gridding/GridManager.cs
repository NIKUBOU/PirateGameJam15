using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.UIElements;

public class GridManager : MonoBehaviour
{
    [Header("Grid Layout")]

    //Controls the width of the grid
    [Tooltip("Keep your aspect ratio in mind (by default, keep a 16:9 ratio)")]
    [SerializeField] private int gridWidth;

    //Controls the height of the grid
    [Tooltip("Keep your aspect ratio in mind (by default, keep a 16:9 ratio)")]
    [SerializeField] private int gridHeight;

    //Holds the tile prefab so that the code can spawn it
    [SerializeField] private Tile tilePrefab;



    [Header("City management")]

    //Controls how many cities can spawn at the start of the game
    [SerializeField] private int maxCitiesAtStart;

    //Controls the rng of the city spawning, a high value will result in more spawns
    [Tooltip("The higher the value, the more spaced out the cities will be (be warned that this may spawn lower the amount of cities that spawn)")]
    [SerializeField] private int cityRandomizationFactor;

    //Holds all the cities currently ingame
    private List<Tile> currentCities;

    //Controls how often do cities expand
    [Tooltip("A higher value will cause expansion cycles to have more time between them")]
    [SerializeField] private float timeBetweenCityExpansionCycles;

    //At which point do cities stop tiering up
    [SerializeField] private int cityMaxTier;

    //What is the required tier for cities to start growing
    [Tooltip("At what city tier do they start expanding?")]
    [SerializeField] private int cityTierRequiredToGrow;



    [Header("Camera control")]

    //Just checks if you want the camera to be moved or not
    [Tooltip("Controls wether the camera automatically calibrates itself to the grid")]
    [SerializeField] private bool centerCamToGrid;

    //Holds the camera's position so it can be moved at the start of the game
    [Tooltip("Unnecessary if you don't want to center the camera")]
    [SerializeField] private Transform cam;

    private void Start()
    {
        //Move the camera
        MoveCamera();

        //Generates the grid
        GenerateGrid();

        //Starts the growth cycle
        StartCoroutine(CallDevelopCities());
    }

    //Moves the camera to the center of the grid if needed
    private void MoveCamera()
    {
        cam.transform.position = new Vector3((float)gridWidth / 2 - .5f, gridHeight-1, (float)gridHeight / 2 - .5f);
        cam.transform.rotation = Quaternion.Euler(90, 0, 0);
    }

    private void GenerateGrid()
    {
        //Creates a list to store the current cities
        currentCities = new List<Tile>();

        //Takes in the height and width values to generated a grid with that many rows and columns
        for (int x = 0; x < gridWidth; x++)
        {
            for (int z = 0; z < gridHeight; z++)
            {
                //Spawns a grid tile
                var spawnedTile = Instantiate(tilePrefab, new Vector3(x, 0, z), Quaternion.identity);
                spawnedTile.name = $"Tile {x} {z}";

                //This part is just to cycle between the base and the offset colors to get a grid pattern (can be removed as needed)
                var isOffset = (x % 2 == 0 && z % 2 != 0) || (x % 2 != 0 && z % 2 == 0);

                //Generates cities
                var isCity = false;

                if (maxCitiesAtStart > currentCities.Count && Random.Range(0, cityRandomizationFactor) == 0)
                {
                    isCity = true;
                    currentCities.Add(spawnedTile);
                }

                //Failsafe spawn 1 city if no cities generated by the time we reach the last tile
                if (x == gridWidth - 1 && z == gridHeight - 1 && currentCities.Count < maxCitiesAtStart)
                {
                    isCity = true;
                    currentCities.Add(spawnedTile);
                }

                //Spawns the tile objects
                spawnedTile.Init(isOffset, isCity, x, z);
            }
        }
    }

    //Does a growth cycle after x amount of time
    private IEnumerator CallDevelopCities()
    {
        while (true)
        {
            yield return new WaitForSeconds(timeBetweenCityExpansionCycles);
            DevelopCities();
        }
    }

    //Makes the cities grow by one tile
    private void DevelopCities()
    {
        //Creates a list of tiles to modify (otherwise when a new city grows it would consider the new city as ungrown)
        List<Tile> citiesToGrow = new List<Tile>();

        //Upgrades tier of cities
        foreach (var spawnedTile in currentCities)
        {
            //If the tile's tier is above 3, it will create a neighboring city
            if (spawnedTile.TileTier >= cityTierRequiredToGrow)
            {
                citiesToGrow.Add(spawnedTile);
            }

            //Upgrades the city's tier
            if (spawnedTile.TileTier < cityMaxTier)
            {
                spawnedTile.TierUp();
            }   
        }

        //Colonize neighboring tiles of tier 3 cities
        foreach (var spawnedTile in citiesToGrow)
        {
            ColonizeNeighbor(spawnedTile);
        }
    }

    private void ColonizeNeighbor(Tile tileToGrow)
    {
        //Checks neighboring tiles if they already are cities
        
        var currentTileXID = tileToGrow.XID;
        var currentTileZID = tileToGrow.ZID;

        // Array to store the coordinates of the neighboring tiles
        var neighbors = new (int x, int z)[]
        {
                (currentTileXID - 1, currentTileZID), // left
                (currentTileXID + 1, currentTileZID), // right
                (currentTileXID, currentTileZID + 1), // above
                (currentTileXID, currentTileZID - 1)  // below
        };

        //Just a list of all the neighboring grass tiles so one can be chosen at random to grow the city
        List<Tile> nonCityNeighborTiles = new List<Tile>();

        // Iterate through the neighbors and perform checks
        foreach (var (x, z) in neighbors)
        {
            // Check if the coordinates are within grid bounds
            if (x >= 0 && x < gridWidth && z >= 0 && z < gridHeight)
            {
                var neighborTile = GameObject.Find($"Tile {x} {z}").GetComponent<Tile>();

                if (!currentCities.Contains(neighborTile))
                {
                    nonCityNeighborTiles.Add(neighborTile);
                }
            }
        }


        //Pick a random neighbor
        if (nonCityNeighborTiles.Count > 0)
        {
            var randomIndex = Random.Range(0, nonCityNeighborTiles.Count);
            var randomNonCityTile = nonCityNeighborTiles[randomIndex];

            //Turns the selected random tile into a city
            randomNonCityTile.Colonize();
            currentCities.Add(randomNonCityTile);
        }
    }
}


